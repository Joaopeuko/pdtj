"{'pdtj': {'type': 'directory', 'files_finder.py': {'type': 'python file', 'docstring_file_parser': {'introduction': 'Parses the docstrings of the classes and functions defined in the given Python file.\\n\\n', 'args': {'file': {'description': '\\n        The name of the Python file to parse.\\n\\n', 'type': <class 'str'>, 'default': 'No default argument'}}, 'returns': \"\\n    A dictionary with the parsed information. The dictionary keys are the names\\n    of the classes or functions defined in the file, and the values are dictionaries\\n    with the parsed information for each class or function.\\n\\nExample:\\n    Given a file `example.py` containing a class `ExampleClass` and a function\\n    `example_function`:\\n\\n    >>> docstring_file_parser('example.py')\\n    {\\n        'ExampleClass': {\\n            'introduction': 'This is the docstring of the ExampleClass.',\\n            'method1': {\\n                'introduction': 'This is the docstring of method1.',\\n                'args': {\\n                    'arg1': {\\n                        'description': 'The first argument.',\\n                        'type': 'str'\\n                    },\\n                    'arg2': {\\n                        'description': 'The second argument.',\\n                        'type': 'int'\\n                    }\\n                },\\n                'return': {\\n                    'description': 'The result of the method.',\\n                    'type': 'float'\\n                }\\n            }\\n        },\\n        'example_function': {\\n            'introduction': 'This is the docstring of example_function.',\\n            'args': {\\n                'arg1': {\\n                    'description': 'The first argument.',\\n                    'type': 'str'\\n                },\\n                'arg2': {\\n                    'description': 'The second argument.',\\n                    'type': 'int'\\n                }\\n            },\\n            'return': {\\n                'description': 'The result of the function.',\\n                'type': 'float'\\n            }\\n        }\\n    }\"}, 'files_parser': {'introduction': 'Recursively parses a directory and its subdirectories for Python files and extracts\\ntheir docstrings as well as other metadata.\\n\\n', 'args': {'path': {'description': '\\n        The path to the directory to be parsed.\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'upper_file': {'description': '\\n        The parent file name of the current directory.\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'current_dictionary': {'description': '\\n        A dictionary to store the metadata extracted from the files.\\n\\n', 'type': <class 'dict'>, 'default': 'No default argument'}}, 'returns': '\\n    The updated `current_dictionary` with the metadata extracted from the files.'}, 'get_directory_type': {'introduction': 'Determines the type of a given path.\\n\\n', 'args': {'possible_directory': {'description': ' A path to check for its type.\\n\\n', 'type': <class 'str'>, 'default': 'No default argument'}}, 'returns': '\\n    The type of the given path. Either \"directory\" or \"file\".\\n\\nExample:\\n    >>> get_directory_type(\\'/path/to/directory\\')\\n    \\'directory\\'\\n    >>> get_directory_type(\\'/path/to/file.txt\\')\\n    \\'file\\''}, 'list_directory': {'introduction': 'Returns a list of files and directories located in the specified path,\\nexcluding items in the REMOVE_ITEMS list.\\n\\n', 'args': {'path': {'description': ' The path to the directory to list.\\n\\n', 'type': <class 'str'>, 'default': 'No default argument'}}, 'returns': '\\n    A list of files and directories in the directory, excluding REMOVE_ITEMS.'}, 'loop_over_current_dictionary': {'introduction': 'Given a module path and a dictionary to add, create nested dictionaries according to the module\\npath and merge the result dictionary. Return the resulting nested dictionary.\\n\\n', 'args': {'module_path': {'description': '\\n        A string representing the path of a module, separated by dots.\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'result': {'description': '\\n        A dictionary to merge with the nested dictionaries.\\n\\n', 'type': <class 'dict'>, 'default': 'No default argument'}}, 'returns': '\\n    A nested dictionary with the keys specified by the module path and the values specified\\n     by the result dictionary.'}}, 'docstring_handler.py': {'type': 'python file', 'docstring_file_parser': {'introduction': 'Parses the docstrings of the classes and functions defined in the given Python file.\\n\\n', 'args': {'file': {'description': '\\n        The name of the Python file to parse.\\n\\n', 'type': <class 'str'>, 'default': 'No default argument'}}, 'returns': \"\\n    A dictionary with the parsed information. The dictionary keys are the names\\n    of the classes or functions defined in the file, and the values are dictionaries\\n    with the parsed information for each class or function.\\n\\nExample:\\n    Given a file `example.py` containing a class `ExampleClass` and a function\\n    `example_function`:\\n\\n    >>> docstring_file_parser('example.py')\\n    {\\n        'ExampleClass': {\\n            'introduction': 'This is the docstring of the ExampleClass.',\\n            'method1': {\\n                'introduction': 'This is the docstring of method1.',\\n                'args': {\\n                    'arg1': {\\n                        'description': 'The first argument.',\\n                        'type': 'str'\\n                    },\\n                    'arg2': {\\n                        'description': 'The second argument.',\\n                        'type': 'int'\\n                    }\\n                },\\n                'return': {\\n                    'description': 'The result of the method.',\\n                    'type': 'float'\\n                }\\n            }\\n        },\\n        'example_function': {\\n            'introduction': 'This is the docstring of example_function.',\\n            'args': {\\n                'arg1': {\\n                    'description': 'The first argument.',\\n                    'type': 'str'\\n                },\\n                'arg2': {\\n                    'description': 'The second argument.',\\n                    'type': 'int'\\n                }\\n            },\\n            'return': {\\n                'description': 'The result of the function.',\\n                'type': 'float'\\n            }\\n        }\\n    }\"}, 'get_elements_position': {'introduction': 'Return a dictionary containing the position of each docstring element in the text.\\n\\n', 'args': {'text': {'description': '\\n        The docstring to parse.\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'docstring_elements': {'description': '\\n        A list of docstring elements to search for.\\n        Defaults to GOOGLE_DOCSTRING_ELEMENTS.\\n\\n', 'type': typing.List[str], 'default': ['Args:', 'Attributes:', 'Examples:', 'Raises:', 'Returns:', 'Yields:']}}, 'returns': '\\n    A dictionary containing the position of each docstring element in the text.'}, 'get_text_documentation_from_element': {'introduction': 'This function returns the cleaned-up text documentation of an element.\\n\\n', 'args': {'element': {'description': ' The element to extract the documentation from.\\n\\n', 'type': <class 'object'>, 'default': 'No default argument'}}, 'returns': '\\n    The cleaned-up text documentation of the element.'}, 'parse_object': {'introduction': 'Parses the docstring of an object and returns a dictionary with the parsed elements.\\n\\n', 'args': {'object_to_parse': {'description': '\\n        The object to parse.\\n\\n', 'type': <class 'object'>, 'default': 'No default argument'}}, 'returns': \"\\n    A dictionary with the parsed elements of the object's docstring.\"}, 'process_args': {'introduction': \"Extracts the arguments and their types from a function's signature.\\n\\n\", 'args': {'func': {'description': ' The function to extract the arguments from.\\n\\n', 'type': <class 'object'>, 'default': 'No default argument'}}, 'returns': '\\n    A dictionary mapping each argument name to its type and default value (if any).'}, 'split_docstring_by_elements': {'introduction': 'Splits a given docstring into sections based on the positions of specified elements.\\n\\n', 'args': {'text': {'description': '\\n        The docstring to be split.\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'elements_position': {'description': '\\n        A dictionary containing the positions of the elements to split the docstring by.\\n\\n', 'type': typing.Dict[int, str], 'default': 'No default argument'}}, 'returns': '\\n    A dictionary containing the sections of the split docstring, where the key is the name of the\\n     section and the value is the text of the section.'}, 'update_args': {'introduction': 'Update the `args_pre_processed_dict` with the values from `arg_dict` and return the updated `pre_processed_dict`.\\n\\n', 'args': {'pre_processed_dict': {'description': '\\n        A dictionary containing the pre-processed information.\\n    ', 'type': <class 'dict'>, 'default': 'No default argument'}, 'args_pre_processed_dict': {'description': '\\n        A dictionary containing the pre-processed information for arguments.\\n    ', 'type': <class 'dict'>, 'default': 'No default argument'}, 'arg_dict': {'description': '\\n        A dictionary containing the argument names and their descriptions and types.\\n\\n', 'type': <class 'dict'>, 'default': 'No default argument'}}, 'returns': '\\n    A dictionary containing the updated pre-processed information.'}}, 'json_generator.py': {'type': 'python file', 'create_docs_and_pdtj_dir': {'introduction': \"Create 'docs' and 'pdtj' directories if they do not already exist.\\n\\nThis function checks whether the 'docs' and 'pdtj' directories exist in the current working directory.\\n If they do not exist, the function creates them using the 'os.makedirs()' method.\\n\\n\", 'args': {}, 'returns': '\\n    None'}, 'files_parser': {'introduction': 'Recursively parses a directory and its subdirectories for Python files and extracts\\ntheir docstrings as well as other metadata.\\n\\n', 'args': {'path': {'description': '\\n        The path to the directory to be parsed.\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'upper_file': {'description': '\\n        The parent file name of the current directory.\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'current_dictionary': {'description': '\\n        A dictionary to store the metadata extracted from the files.\\n\\n', 'type': <class 'dict'>, 'default': 'No default argument'}}, 'returns': '\\n    The updated `current_dictionary` with the metadata extracted from the files.'}, 'get_arguments': {'introduction': ''}, 'get_directory_type': {'introduction': 'Determines the type of a given path.\\n\\n', 'args': {'possible_directory': {'description': ' A path to check for its type.\\n\\n', 'type': <class 'str'>, 'default': 'No default argument'}}, 'returns': '\\n    The type of the given path. Either \"directory\" or \"file\".\\n\\nExample:\\n    >>> get_directory_type(\\'/path/to/directory\\')\\n    \\'directory\\'\\n    >>> get_directory_type(\\'/path/to/file.txt\\')\\n    \\'file\\''}, 'main': {'introduction': ''}}, 'util.py': {'type': 'python file', 'check_dir_existence': {'introduction': 'Checks whether a file or directory exists at the specified path.\\n\\n', 'args': {'path': {'description': '\\n        The path to the directory containing the file or directory to check.\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'file_name': {'description': '\\n        The name of the file or directory to check for existence.\\n\\n', 'type': <class 'str'>, 'default': 'No default argument'}}, 'returns': '\\n    True if the file or directory exists, False otherwise.'}, 'create_docs_and_pdtj_dir': {'introduction': \"Create 'docs' and 'pdtj' directories if they do not already exist.\\n\\nThis function checks whether the 'docs' and 'pdtj' directories exist in the current working directory.\\n If they do not exist, the function creates them using the 'os.makedirs()' method.\\n\\n\", 'args': {}, 'returns': '\\n    None'}, 'create_single_dir': {'introduction': 'Creates a single directory with the given `folder_name` at the specified `path`.\\n\\n', 'args': {'path': {'description': '\\n        The path to create the directory at.\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'folder_name': {'description': '\\n        The name of the directory to create.\\n\\n', 'type': <class 'str'>, 'default': 'No default argument'}}, 'returns': '\\n    None'}}, 'parameters.py': {'type': 'python file', 'SafeLoader': {'introduction': '', '__init__': {'introduction': 'Initialize the scanner.'}, 'add_indent': {'introduction': ''}, 'ascend_resolver': {'introduction': ''}, 'check_block_entry': {'introduction': ''}, 'check_data': {'introduction': ''}, 'check_directive': {'introduction': ''}, 'check_document_end': {'introduction': ''}, 'check_document_start': {'introduction': ''}, 'check_event': {'introduction': ''}, 'check_key': {'introduction': ''}, 'check_node': {'introduction': ''}, 'check_plain': {'introduction': ''}, 'check_printable': {'introduction': ''}, 'check_resolver_prefix': {'introduction': ''}, 'check_state_key': {'introduction': 'Block special attributes/methods from being set in a newly created\\nobject, to prevent user-controlled methods from being called during\\ndeserialization'}, 'check_token': {'introduction': ''}, 'check_value': {'introduction': ''}, 'compose_document': {'introduction': ''}, 'compose_mapping_node': {'introduction': ''}, 'compose_node': {'introduction': ''}, 'compose_scalar_node': {'introduction': ''}, 'compose_sequence_node': {'introduction': ''}, 'construct_document': {'introduction': ''}, 'construct_mapping': {'introduction': ''}, 'construct_object': {'introduction': ''}, 'construct_pairs': {'introduction': ''}, 'construct_scalar': {'introduction': ''}, 'construct_sequence': {'introduction': ''}, 'construct_undefined': {'introduction': ''}, 'construct_yaml_binary': {'introduction': ''}, 'construct_yaml_bool': {'introduction': ''}, 'construct_yaml_float': {'introduction': ''}, 'construct_yaml_int': {'introduction': ''}, 'construct_yaml_map': {'introduction': ''}, 'construct_yaml_null': {'introduction': ''}, 'construct_yaml_object': {'introduction': ''}, 'construct_yaml_omap': {'introduction': ''}, 'construct_yaml_pairs': {'introduction': ''}, 'construct_yaml_seq': {'introduction': ''}, 'construct_yaml_set': {'introduction': ''}, 'construct_yaml_str': {'introduction': ''}, 'construct_yaml_timestamp': {'introduction': ''}, 'descend_resolver': {'introduction': ''}, 'determine_encoding': {'introduction': ''}, 'dispose': {'introduction': ''}, 'fetch_alias': {'introduction': ''}, 'fetch_anchor': {'introduction': ''}, 'fetch_block_entry': {'introduction': ''}, 'fetch_block_scalar': {'introduction': ''}, 'fetch_directive': {'introduction': ''}, 'fetch_document_end': {'introduction': ''}, 'fetch_document_indicator': {'introduction': ''}, 'fetch_document_start': {'introduction': ''}, 'fetch_double': {'introduction': ''}, 'fetch_flow_collection_end': {'introduction': ''}, 'fetch_flow_collection_start': {'introduction': ''}, 'fetch_flow_entry': {'introduction': ''}, 'fetch_flow_mapping_end': {'introduction': ''}, 'fetch_flow_mapping_start': {'introduction': ''}, 'fetch_flow_scalar': {'introduction': ''}, 'fetch_flow_sequence_end': {'introduction': ''}, 'fetch_flow_sequence_start': {'introduction': ''}, 'fetch_folded': {'introduction': ''}, 'fetch_key': {'introduction': ''}, 'fetch_literal': {'introduction': ''}, 'fetch_more_tokens': {'introduction': ''}, 'fetch_plain': {'introduction': ''}, 'fetch_single': {'introduction': ''}, 'fetch_stream_end': {'introduction': ''}, 'fetch_stream_start': {'introduction': ''}, 'fetch_tag': {'introduction': ''}, 'fetch_value': {'introduction': ''}, 'flatten_mapping': {'introduction': ''}, 'forward': {'introduction': ''}, 'get_data': {'introduction': ''}, 'get_event': {'introduction': ''}, 'get_mark': {'introduction': ''}, 'get_node': {'introduction': ''}, 'get_single_data': {'introduction': ''}, 'get_single_node': {'introduction': ''}, 'get_token': {'introduction': ''}, 'need_more_tokens': {'introduction': ''}, 'next_possible_simple_key': {'introduction': ''}, 'parse_block_mapping_first_key': {'introduction': ''}, 'parse_block_mapping_key': {'introduction': ''}, 'parse_block_mapping_value': {'introduction': ''}, 'parse_block_node': {'introduction': ''}, 'parse_block_node_or_indentless_sequence': {'introduction': ''}, 'parse_block_sequence_entry': {'introduction': ''}, 'parse_block_sequence_first_entry': {'introduction': ''}, 'parse_document_content': {'introduction': ''}, 'parse_document_end': {'introduction': ''}, 'parse_document_start': {'introduction': ''}, 'parse_flow_mapping_empty_value': {'introduction': ''}, 'parse_flow_mapping_first_key': {'introduction': ''}, 'parse_flow_mapping_key': {'introduction': ''}, 'parse_flow_mapping_value': {'introduction': ''}, 'parse_flow_node': {'introduction': ''}, 'parse_flow_sequence_entry': {'introduction': ''}, 'parse_flow_sequence_entry_mapping_end': {'introduction': ''}, 'parse_flow_sequence_entry_mapping_key': {'introduction': ''}, 'parse_flow_sequence_entry_mapping_value': {'introduction': ''}, 'parse_flow_sequence_first_entry': {'introduction': ''}, 'parse_implicit_document_start': {'introduction': ''}, 'parse_indentless_sequence_entry': {'introduction': ''}, 'parse_node': {'introduction': ''}, 'parse_stream_start': {'introduction': ''}, 'peek': {'introduction': ''}, 'peek_event': {'introduction': ''}, 'peek_token': {'introduction': ''}, 'prefix': {'introduction': ''}, 'process_directives': {'introduction': ''}, 'process_empty_scalar': {'introduction': ''}, 'remove_possible_simple_key': {'introduction': ''}, 'resolve': {'introduction': ''}, 'save_possible_simple_key': {'introduction': ''}, 'scan_anchor': {'introduction': ''}, 'scan_block_scalar': {'introduction': ''}, 'scan_block_scalar_breaks': {'introduction': ''}, 'scan_block_scalar_ignored_line': {'introduction': ''}, 'scan_block_scalar_indentation': {'introduction': ''}, 'scan_block_scalar_indicators': {'introduction': ''}, 'scan_directive': {'introduction': ''}, 'scan_directive_ignored_line': {'introduction': ''}, 'scan_directive_name': {'introduction': ''}, 'scan_flow_scalar': {'introduction': ''}, 'scan_flow_scalar_breaks': {'introduction': ''}, 'scan_flow_scalar_non_spaces': {'introduction': ''}, 'scan_flow_scalar_spaces': {'introduction': ''}, 'scan_line_break': {'introduction': ''}, 'scan_plain': {'introduction': ''}, 'scan_plain_spaces': {'introduction': ''}, 'scan_tag': {'introduction': ''}, 'scan_tag_directive_handle': {'introduction': ''}, 'scan_tag_directive_prefix': {'introduction': ''}, 'scan_tag_directive_value': {'introduction': ''}, 'scan_tag_handle': {'introduction': ''}, 'scan_tag_uri': {'introduction': ''}, 'scan_to_next_token': {'introduction': ''}, 'scan_uri_escapes': {'introduction': ''}, 'scan_yaml_directive_number': {'introduction': ''}, 'scan_yaml_directive_value': {'introduction': ''}, 'stale_possible_simple_keys': {'introduction': ''}, 'unwind_indent': {'introduction': ''}, 'update': {'introduction': ''}, 'update_raw': {'introduction': ''}}}, 'constants.py': {'type': 'python file'}, '__version__.py': {'type': 'python file'}, 'shelve': 'finance', 'sub-project': 'pdtj'}}"
